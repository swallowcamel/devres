using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

/* 
 * =====================外观模式 Facade=========================
 * 
 * 定义：为子系统中的一组接口提供一个一致的界面,此模式定义了一个高层接口,这个接口使得这一子系统调用更加容易使用。[DP]
 *  
 * 适用：1、当你要为一个复杂子系统提供一个简单接口时。子系统往往因为不断演化而变得越来越复杂。
 *         大多数模式使用时都会产生更多更小的类。这使得子系统更具可重用性，也更容易对子系统进行定制，
 *         但这也给那些不需要定制子系统的用户带来一些使用上的困难。Facade 可以提供一个简单的缺省视图，
 *         这一视图对大多数用户来说已经足够，而那些需要更多的可定制性的用户可以越过Facade层。 
 *         
 *      2、客户程序与抽象类的实现部分之间存在着很大的依赖性。引入Facade 将这个子系统与客户以及其他的子系统分离，
 *         可以提高子系统的独立性和可移植性。 
 *         
 *      3、当你需要构建一个层次结构的子系统时，使用facade模式定义子系统中每层的入口点。
 *         如果子系统之间是相互依赖的，你可以让它们仅通过facade进行通讯，从而简化了它们之间的依赖关系。
 * 
 * 参考："Design Patterns", p185,ISBN:0-201-63361-2
 * 
 * 什么时候使用，要分阶段来考虑：
 *  1、在设计初期阶段，应该要有意识的将不同的两个层分离。层与层之间建立外观Facade。
 *  2、在开发阶段子系统往往因为不断的重构演化而变得越来越复杂，增加外观Facade可以提供一个简单的接口减少了它们之间的依赖。
 *  3、在维护一个遗留的大型系统时，可能这个系统已经非常难以维护和扩展了，为新系统开发一个外观Facade类，
 *     来提供设计粗糙或高度复杂的遗留代码的比较清晰简单的接口，让新系统与Facade对象交互，Facade与遗留代码交互所有复杂的工作。
 * 
 * 
 * 注意：
 * 
 * PS：Facade模式体现了依赖倒置原则和迪米特法则思想，是一个比较常用的模式。
 * 
 */

namespace DesignPattern.Facade
{
    class Program
    {
        static void Main(string[] args)
        {
            var facade = new Facade();
            facade.MethodA();
            facade.MethodB();

            Console.ReadLine();
        }
    }
}
