观察者，定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。
模板方法，定义一个操作的算法骨架，而将一些步骤延迟到子类中，模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。
命令，将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；可以对请求排队或记录请求日志，以及支持可撤销的操作。
状态，允许一个对象在其内部状态改变时改变它的行为，让对象看起来似乎修改了它的类。
职责链，使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。

代码重复是编程中最常见、最糟糕的‘坏味道’，如果我们在一个以上的地方看到相同的程序结构，那么可以肯定，设法将他们和而为一，程序会变得更好。
完全相同的代码当然存在明显的重复，而微妙的重复会出现在表面不同但是本质相同的结构或处理步骤中。

模板方法模式由一个抽象类组成，这个抽象类定义了需要覆盖的可能有不同实现的模板方法，每个从这个抽象类派生的具体类将为此模板实现新方法。

请求发送者与具体实现者分离的好处是：将调用操作的对象与知道如何实现该操作的对象解耦，在不同的时刻指定、排列和执行请求，支持取消/重做的操作。记录整个操作日志。支持事务。


有多个对象可以处理一个请求，哪个对象处理该请求事先并不知道，要在运行时刻自动确定。
让客户在不明确指定接收者的情况下，提交一个请求，然后由所有能处理这请求的对象连成一条链，
并沿着这条链传递该请求，直到有一个对象处理它为止。

状态模式提供了一个更好的办法来组织与特定状态相关的代码，决定状态转移的逻辑不在单块
的if或switch中，而是分布在各个状态子类之间，由于所有与状态相关的代码都存在于摸个状态子类中，所以通过定义新的子类可以很容易地增加新的状态和转换。


============================

解释器，给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。
中介者，用一个中介对象来封装一系列的对象交互，中介者使得各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。
访问者，表示一个作用于某对象结构中的各个元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。
策略模式：定义一系列算法，把它们一个个封装起来，并且使它们可以相互替换。使得算法可独立于使用它的客户而变化。
备忘录：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可以将该对象恢复到原先保存的状态。
迭代器，提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。


如果一种特定类型的问题发生的频率足够高，那么就可以考虑将该问题的各个实例表述为一个简单语言中的句子。通过构建一个解释器，该解释器解释这些句子来解决该问题。

将集体行为封装一个单独的中介者对象来避免对象间连接太多的问题，中介者负责控制和协调一组对象间的交互。中介者充当一个中介以使组中的对象不再相互显示的引用，对象仅知道中介者，从而减少了相互连接的数目。
其实就是迪米特原则提倡的 最少知识原则，也就是如何减少耦合问题，类之间的耦合越弱，越有利于复用。

访问者增加具体的Element是困难的，但增加依赖于复杂对象结构的构件的操作就变的容易。仅需要增加一个新的访问者即可在一个对象结构上定义一个新的操作。

优先使用对象组合，而非类继承？
继承提供了一种支持多种算法或行为的方法，我们可以直接生成一个类A的子类B、C、D从而给它以不同的行为。
但这样会将行为硬行编制到父类A当中，而将算法的事先于类A的实现混合起来，从而使得类A难以理解、难以维护和扩展，而且还不能动态地改变算法，仔细分析会发现，它们之间的唯一差别是它们所使用的算法或行为，
将算法封装在独立的策略类中使得你可以独立于其类A改变它，使它易于切换理解、扩展。

在保存对象的内部状态时，为何需要考虑不破坏封装细节的前提？
通常原对象A都有很多状态属性，保存对象的内部状态，其实也就是将这些状态属性的值记录到A对象外部的另外一个对象B，
但是如果记录的过程是对外透明的，那就意味着保存过程耦合了对象状态细节。

备忘录就是解决这个问题的，它可以避免暴露一些只应由对象A管理却又必须存储在对象A之外的信息。
备忘录模式把可能很复杂的对象A的内部信息对其他对象屏蔽起来，从而保持了封装边界。

迭代器模式的关键思想是将对列表的访问和遍历从列表对象中分离出来并放入一个迭代器对象中，迭代器类定义了一个访问该列表元素的接口。迭代器对象负责跟踪当前的元素，并且知道哪些元素已经遍历过了。
