抽象工厂：提供一个创建一系列或相关依赖对象的接口，而无需指定它们的具体类。
建造者：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。
工厂方法：定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂模式使一个类的实例化延迟到其子类。
原型模式：用户原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。
单例模式：保证一个类仅有一个实例，并提供一个访问它的全局访问点。

创建型模式隐藏了这些类的实例是如何被创建和放在一起，整个系统关于这些对象所知道的是由抽象类所定义的接口。
这样，创建型模式在创建了什么、谁创建它、它是怎么被创建的，以及何时被创建这些方面提供了很大的灵活性。

当一个系统应该独立于它的产品创建、构成和表示时，应该考虑用创建型模式
建立相应数量的原型并克隆它们通常比每次用合适状态手工实例化该类更方便一些。

内聚性描述的是一个例程内部组成部分之间相互联系的紧密程度。而耦合性描述的是一个例程与其它例程之间联系的紧密程度。
软件开发的目标应该是创建这样的例程：内部完成，也就是高内聚，而与其它例程之间的联系则是小巧、直接、可见、灵活的，
这就是松耦合。

建造者模式通过将复杂的对象的构建与它的表示分离来实践松耦合，用同样的构建过程创建不同的产品给客户。

对一些类来说，一个实例是很重要的，单例的优势就是让类自身负责保存它的唯一实例。
这个类可以保证没有其它实例可以被创建，并且还提供了一个访问该实例的方法，这样就可以
对唯一的实例可以严格地控制客户怎样以及何时访问它。

创建型模式抽象了实例化的过程。它们帮助一个系统独立于如何创建、组合和表示它的那些对象。
创建型模式都会将关于该系统使用哪些具体的类的信息封装起来。允许客户用结构和功能差别很大的‘产品’对象配置一个系统。
配置可以是静态的，即在编译时指定，也可以是动态的，就是运行时再指定。

工厂方法与其它几种创建型模式相比的优势：

通常设计应该是从工厂方法开始，当设计者发现需要更大的灵活性时，设计便会向其它创建型模式演化。
当设计者在设计标准之间进行权衡时，了解多个创建型模式可以给设计者更多的选择余地。

单一职责：单例
开放封闭：工厂方法





